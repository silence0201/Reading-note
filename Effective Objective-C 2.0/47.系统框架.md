#熟悉系统框架
* 许多系统框架都可以直接使用.其中最重要的是`Foundation`和`CoreFoundation`,这两个框架提供了构建应用程序所需的许多核心功能
* 很多常见任务都能用框架来做,例如音频与视频处理/网络通信/数据管理等
* 用纯C写成的框架与用Objective-C写成的一样重要,若想成为优秀的Objective-C开发者,应该掌握C语言的核心概念

#多用块枚举,少用for循环
* 遍历集合有四种方式,最基本的方法是	`for循环`,其次是`NSEnumerator`遍历法及快速遍历法,最新/最先进的方式则是`块枚举法`
* `块枚举法`本身就能通过GCD来并发执行遍历操作,无须另行编写代码,而采用其他遍历方式则无法轻易实现这一点
* 若提前知道遍历的集合含有某种对象,则应该修改签名,指出对象的具体类型

#对自定义其内存管理语句的集合使用无缝桥接
* 通过排无缝桥接技术,可以在`Foundation`框架中的`Objective-C`对象与`CoreFoundation`框架中的C语言数据结构之间进行转换
* 在`CoreFoundation`层面创建集合时,可以指定许多回调函数,这些函数表示此集合该如何处理其元素,然而可运用无缝桥接技术,将其转换为具备特殊内存管理语句的Objective-C集合

#构建缓存时选用NSCache而非NSDictionary
* 实现缓存时应选用NSCache而非NSDictionary对象,因为NSCache可以提供优雅的自动删减功能,而非`线程安全`,此外,与字典不同,并不会拷贝键
* 可以给NSCache对象设置上限,用以限制缓存中对象的总个数及`总成本`,而这些尺度则定义了缓存删减其中对象的时机.但是绝对不要把这些尺度当成可靠的`硬限制`,他们仅对NSCache起知道作用

#精简initialize和load的实现代码
* 在加载阶段,如果类实现了load方法,那么系统就会调用它,分类里也可以定义此方法,类的load方法要比分类的县调用,与其他方法不同,load方法不参与覆写机制
* 首次使用某个类之前,系统会向其发送initalize消息,由于此方法遵从普通的覆写规则,所以通常应该在里面判断当前要初始化那个类
* load和initalize应该尽可能简单

#别忘了NSTimer会保留其目标对象
* NStimer对象会保留其目标,直到计时器本身失效为止,调用invalidate方法可令计时器失效,另外,一次性的计数器在触发任务之后也会失效
* 反复执行任务的计时器,很容易引入保留环,如果这种计时器的目标对象又保留了计时器本省,那肯定会导致保留环.这种环装保留关系,可能是直接发生的,也可能是通过对象图的其他对象简介发生的
* 可以扩充NSTimer的功能,用块来打破保留环,不过,除非`NSTimer`将来在公共接口里面提供此功能,否则必须创建分类将实现代码加入其中


	